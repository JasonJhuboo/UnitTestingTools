using FakeItEasy;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

namespace JhubooSoft.UnitTestingTools
{
    /// <summary>
    /// Automatically fakes out the constructor parameters of a given type for test purposes.
    /// </summary>
    /// <typeparam name="TObjectType">The type of object our factory creates</typeparam>
    /// <remarks>
    /// Use this object factory to create auto-stubbed instances that you can test against. The stubs are generated by fake-it-easy and can be over-ridden if required.
    /// See test cases for detailed usage examples.
    /// </remarks>
    public class AutoFakedObjectFactory<TObjectType>
        where TObjectType : class
    {
        #region Fields

        private static MethodInfo m_FakeInstanceDelegateMethodInfo;
        private Dictionary<Type, object> m_PreConstructedConstructorParameters = new Dictionary<Type, object>();
        private Dictionary<Type, object> m_ConstructorParametersThatWereUsedDuringCreate = new Dictionary<Type, object>();
        #endregion

        #region Properties

        internal MethodInfo FakeInstanceDelegateMethodInfo
        {
            get
            {
                if (m_FakeInstanceDelegateMethodInfo == null)
                    m_FakeInstanceDelegateMethodInfo = this.GetType().GetMethod(nameof(FakeInstanceDelegate), BindingFlags.NonPublic | BindingFlags.Static);

                return m_FakeInstanceDelegateMethodInfo;
            }
        }

        #endregion

        #region Methods

        /// <summary> Create an auto-stubbed instance of type <see cref="TObjectType"/>.</summary>
        /// <remarks> The type of <see cref="TObjectType"/> should be a class which as a single constructor.</remarks>
        public TObjectType Create()
        {
            ConstructorInfo constructorInfo = GetConstructorInfo();
            object[] constructorParameters = GetConstructorParameters(constructorInfo);
            object constructed = constructorInfo.Invoke(constructorParameters);

            return (TObjectType)constructed;
        }

        /// <summary> Override the automatic stubbing of a single constructor parameter to provide a custom implementation of a dependency to use during object creation.</summary>
        /// <remarks> This method can be called repeteadly for different contructor parameters. </remarks>
        /// <typeparam name="TInterface">The type to provide a custom implementation for</typeparam>
        /// <param name="instanceToUseWhenConstructing">The instance to use when constructing the type of <see cref="TObjectType"/></param>
        public void UseWhenConstructing<TInterface>(TInterface instanceToUseWhenConstructing)
        {
            if (m_PreConstructedConstructorParameters.ContainsKey(typeof(TInterface)))
                throw new InvalidOperationException($"The type {typeof(TInterface)} has already been overridden for creation of {typeof(TObjectType)}");

            m_PreConstructedConstructorParameters.Add(typeof(TInterface), instanceToUseWhenConstructing);
        }

        public TInterface GetConstructorParameter<TInterface>()
        {
            if (m_ConstructorParametersThatWereUsedDuringCreate.TryGetValue(typeof(TInterface), out object preConstructedParameter))
                return (TInterface)preConstructedParameter;

            throw new ArgumentException($"Type of {typeof(TInterface)} not used in construction of {typeof(TObjectType)}");
        }

        private object[] GetConstructorParameters(ConstructorInfo constructorInfo)
        {
            ParameterInfo[] parameterInfo = constructorInfo.GetParameters();

            if (parameterInfo?.Length == 0)
                return Array.Empty<object>();

            foreach (ParameterInfo paramaterMetadata in parameterInfo)
            {
                if (m_PreConstructedConstructorParameters.TryGetValue(paramaterMetadata.ParameterType, out object preConstructedParameter))
                    m_ConstructorParametersThatWereUsedDuringCreate.Add(paramaterMetadata.ParameterType, preConstructedParameter);
                else
                    m_ConstructorParametersThatWereUsedDuringCreate.Add(paramaterMetadata.ParameterType, MakeFakedInstance(paramaterMetadata));
            }

            return m_ConstructorParametersThatWereUsedDuringCreate.Select(x => x.Value).ToArray();
        }

        private object MakeFakedInstance(ParameterInfo paramaterMetadata)
        {
            MethodInfo genericMethod = FakeInstanceDelegateMethodInfo.MakeGenericMethod(new Type[] { paramaterMetadata.ParameterType });
            return genericMethod.Invoke(this, Array.Empty<object>());
        }

        private static object FakeInstanceDelegate<TFakeType>()
            where TFakeType : class
        {
            return A.Fake<TFakeType>();
        }

        private ConstructorInfo GetConstructorInfo()
        {
            ConstructorInfo[] constructors = typeof(TObjectType).GetConstructors(BindingFlags.Public | BindingFlags.Instance);
            if (constructors.Length > 1)
                throw new InvalidOperationException("Unable to auto construct an object with multiple constructors.");

            return constructors[0];
        }

        #endregion
    }
}